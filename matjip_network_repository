import 'dart:core';
import 'dart:io';

import 'package:algolia/algolia.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:get/get.dart';
import 'package:matjipmemo/constants/firestore_keys.dart';
import 'package:matjipmemo/constants/logger.dart';
import 'package:matjipmemo/controller/others_controller_deprecated.dart';
import 'package:matjipmemo/controller/square_controller.dart';
import 'package:matjipmemo/controller/login_controller.dart';
import 'package:matjipmemo/controller/manager_controller.dart';
import 'package:matjipmemo/controller/tag_controller_deprecated.dart';
import 'package:matjipmemo/models/firebase/matjip_model.dart';
import 'package:matjipmemo/models/firebase/user_model.dart';
import 'package:matjipmemo/widget/dialog_widet.dart';

import '../main.dart';
import '../tools/image_tools.dart';
import 'helper/transformers.dart';

class MatjipNetworkRepository with Transformers{
  static final MatjipNetworkRepository _matjipNetworkRepository = MatjipNetworkRepository._internal();
  factory MatjipNetworkRepository() => _matjipNetworkRepository;
  MatjipNetworkRepository._internal();


  Query squareQuery = FirebaseFirestore.instance.collection(COLLECTION_MATJIP)
      .orderBy(KEY_CREATED, descending: true).where(KEY_VISITED, isEqualTo: true)
      .where(KEY_WRITERPRIVATE, isEqualTo: false).where(KEY_INVISIBLE, isEqualTo: false).where(KEY_WRITER_BANNED, isEqualTo: false);
  Query otherQuery = FirebaseFirestore.instance.collection(COLLECTION_MATJIP)
      .orderBy(KEY_CREATED, descending: true)
      .where(KEY_WRITERPRIVATE, isEqualTo: false).where(KEY_INVISIBLE, isEqualTo: false)
      .where(KEY_WRITER_BANNED, isEqualTo: false);




  Stream<MatjipModel> getMatjipModelStream(String matjipId, ){
    logger.d('ÎßõÏßëid->'+matjipId);
    return FirebaseFirestore.instance.collection(COLLECTION_MATJIP).doc(matjipId).snapshots().transform(toMatjip);
  }
  Future<MatjipModel?> getMatjipModel(String matjipId, ) async{
    logger.d('ÎßõÏßëid->'+matjipId);
    var snapshot = await FirebaseFirestore.instance.collection(COLLECTION_MATJIP).doc(matjipId).get();
    if(snapshot.exists){
      return MatjipModel.fromSnapshot(snapshot);
    }else{return null;}
  }

  Future<List<MatjipModel>> getMatjipListFromPlace(String placeid, {MatjipModel? matjipModel}) async{
    List<MatjipModel> resultList=[];
    var querySnapshot =await squareQuery.where(KEY_PLACE_ID, isEqualTo: placeid).get();
    logger.d('getMatjipListFromPlace($placeid) total number : ${querySnapshot.size}');
    for(int i=0; i<querySnapshot.docs.length;i++)
    {
      resultList.add(MatjipModel.fromSnapshot(querySnapshot.docs[i]));
    }
   /* if(resultList.length==0&& matjipModel!=null && (matjipModel.matjipid?.isNotEmpty??false)){ //Îã§Î•∏ ÎßõÏßëÎì§ ÏóÜÏùÑ Îïå placeÏóê ÎßõÏßë Ï∂îÍ∞ÄÌï¥ÏÑú Ïò¨Î¶¨Í∏∞
    resultList.add(matjipModel);
    FirebaseFirestore.instance.collection(COLLECTION_MATJIP).doc(matjipModel.matjipid).update({KEY_PLACE_ID: placeid});
    }*/
    return resultList;
  }

  Future<MatjipModel> likeMatjipModel({required MatjipModel matjipModel, required UserModel userModel,
    required bool like //true -> like, false unlike
  }) async{
    MatjipModel newMatjipModel = matjipModel;
    logger.d('likeMatjipModel like-> $like');
    DocumentReference matjipRef = FirebaseFirestore.instance.collection(COLLECTION_MATJIP).doc(matjipModel.matjipid);
    DocumentReference likerRef = matjipRef.collection(COLLECTION_LIKE).doc(userModel.uid);
    DocumentSnapshot matjipSnapshot  = await matjipRef.get();
    if(matjipSnapshot.exists){
      if(like){
        logger.d('likeMatjipModel like-> 1');
        await FirebaseFirestore.instance.runTransaction((transaction) async{
          transaction.update(matjipRef, {KEY_LISTOFLIKES : FieldValue.arrayUnion([userModel.uid]), KEY_COUNTLIKES : matjipModel.listoflikes.length+1});
          transaction.set(likerRef, userModel.toJson() , SetOptions(merge: true) );
        });
        newMatjipModel.listoflikes.add(userModel.uid);
        newMatjipModel.countlikes = newMatjipModel.listoflikes.length;
      }
      else{
        logger.d('likeMatjipModel like-> 2');
        await FirebaseFirestore.instance.runTransaction((transaction) async{
          transaction.update(matjipRef, {KEY_LISTOFLIKES : FieldValue.arrayRemove([userModel.uid]), KEY_COUNTLIKES : matjipModel.listoflikes.length-1});
          transaction.delete(likerRef,);
        });
        newMatjipModel.listoflikes.remove(userModel.uid);
        newMatjipModel.countlikes = newMatjipModel.listoflikes.length;
      }
     // DocumentSnapshot newmatjipSnapshot  = await matjipRef.get();
     // MatjipModel newMatjipModel = MatjipModel.fromSnapshot(newmatjipSnapshot);
      Get.find<ManagerController>().updateMatjip(newMatjipModel);
      Get.find<SquareController>().updateMatjip(newMatjipModel);
      logger.d('likeMatjipModel like-> 3 $newMatjipModel');
      //Get.find<TagController>().updateMatjip(newMatjipModel);
     // Get.find<OthersController>().updateMatjip(matjipModel.makeruid!, newMatjipModel);
      return newMatjipModel;
    }else{
      return matjipModel;
    }
  }


  Future<DocumentReference> makeNewDocRef(String uid) async{
    DocumentReference matjipRef = FirebaseFirestore.instance.collection(COLLECTION_USERS).doc(uid).collection(COLLECTION_MATJIP).doc();
    return matjipRef;
  }
  Future<String> thumbUrl(String originalUrl) async{
 try{
   FirebaseStorage storage = FirebaseStorage.instance;
   var ref = storage.refFromURL(originalUrl);
   var thumbref = storage.ref('${ref.parent!.fullPath}/thumb_${ref.name}');
   var result = await thumbref.getDownloadURL();
   return result;
 }catch(e){
   return originalUrl;
 }
  }

  Future<MatjipModel> thumbUpdate(MatjipModel matjipModel) async{
    List imageUrls = matjipModel.imageurls;
    List thumbUrls = [];
    if(imageUrls.length!=0){
      for(int i=0; i<imageUrls.length;i++)
      {
        var thumburl =  await thumbUrl(imageUrls[i]);
        thumbUrls.add(thumburl);
      }
      matjipModel.thumbnailImageurls = thumbUrls;
    }
    return matjipModel;
  }
  void requestThumb(MatjipModel matjipModel) async{
    //deprecated 22.05.30
   /* if(matjipModel.imageurls.isEmpty){
      logger.d('Ïù¥ÎØ∏ÏßÄ ÏóÜÏùå');
      DocumentReference matjipRef=FirebaseFirestore.instance.collection(COLLECTION_MATJIP).doc(matjipModel.matjipid);
      matjipRef.update({KEY_THUMBNAILURLS:[]});
      return;}
    var dio = Dio();
    logger.d('Ïù¥ÎØ∏ÏßÄ Í∞ØÏàò ${matjipModel.imageurls.length}');
    String url = "https://asia-northeast3-matjipmemo.cloudfunctions.net/generate_matjip_thumb-generate_matjip_thumb";
    dio.get(url, queryParameters: {"matjipModel": matjipModel.toJson()});*/
  }

  Future uploadMatjip(MatjipModel matjipModel, String uid, {bool update=false, required List deleteUrls} ) async{
    DocumentReference matjipRef = FirebaseFirestore.instance.collection(COLLECTION_MATJIP).doc(matjipModel.matjipid);
    DocumentReference placeRef = FirebaseFirestore.instance.collection(COLLECTION_PLACES).doc(matjipModel.toPlaceId());
    if(update){
      matjipRef.update(matjipModel.toJson());
      //Ïù¥ÎØ∏ÏßÄ Ìï¥Î¥êÏïº ÏñºÎßà Ïïà ÌÅ∞ Îç∞ Í∑∏ÎåÄÎ°ú ÎëêÏûê! 22.06.02
      /*FirebaseStorage storage = FirebaseStorage.instance;
      deleteUrls.forEach((element) {
        var ref = storage.refFromURL(element);
        var thumbref = storage.ref('${ref.parent!.fullPath}/thumb_${ref.name}');
        logger.d(ref.fullPath);
        logger.d(thumbref.fullPath);
        //ref.delete();
       //thumbref.delete();
        //ÏùºÎ∞ò refÎäî ÏßÄÏö∞Î©¥ ÏïàÎêúÎã§.  Î™®ÏûÑÏù¥ÎÇò, Î¶¨Ïä§Ìä∏ÏóêÏÑú ÏÇ≠Ï†úÎêòÎ©¥ ÏïÑÏòà ÏïàÎÇòÏò®Îã§.
        // thumrefÎäî ÏßÄÏõåÏ§òÏïºÌïúÎã§.   thumbÎäî ÎåÄÌëúÏÇ¨ÏßÑÏù¥ÎùºÏÑú ÏßÄÏõåÏ§òÏïº Îê®
      });*/
    }else{  matjipRef.set(matjipModel.toJson());
      if (!matjipModel.invisible && !matjipModel.shortDescription && !matjipModel.writerprivate && matjipModel.visited)
         placeRef.set(matjipModel.toJson()..addAll({KEY_COUNT_MATJIP: FieldValue.increment(1) }), SetOptions(merge: true));
    }
    logger.d('ÏûëÏÑ± ÏôÑÎ£å');
    return;
  }




  Future<bool> deleteMatjipModel(MatjipModel matjipModel) async{
    var result = await realDeleteDialog();
    if (result == false){return false;}else{
      //ÎßõÏßë ÏßÄÏö∞Í∏∞
      //1.ÎßõÏßëÏù¥ÎØ∏ÏßÄ ÌååÏùº ÏßÄÏö∞Í∏∞(storage) -> Ïù¥ÎØ∏ÏßÄ ÏßÄÏö∞Î©¥, matjipMoimÏù¥ÎÇò Î¶¨Ïä§Ìä∏ÏóêÏÑúÎèÑ Îã§ ÏßÄÏõåÏßÄÎãà, Ïù¥ÎØ∏ÏßÄÎäî ÎÇ®Í≤®Îëò Í≤É
      /*Reference storageReference =  FirebaseStorage.instance.ref().child('$COLLECTION_USERS/${matjipModel.makeruid}/$COLLECTION_MATJIP/${matjipModel.matjipid}');
      var listref = await storageReference.listAll();
      var filelist = listref.items;
      filelist.forEach((element) {
        element.delete();
      });*/
      //2.ÎßõÏßëÏ†ïÎ≥¥ ÏßÄÏö∞Í∏∞(firestore)
      DocumentReference matjipRef = FirebaseFirestore.instance.collection(COLLECTION_MATJIP).doc(matjipModel.matjipid);
      matjipRef.delete().then((value) => logger.d("matjipModel ${matjipModel.matjipid} Deleted"));
      return true;
    }
  }

  Future<String> uploadImageForWriteMatjip( {required File image, required String docname, required int index, required Timestamp timestamp1}) async{
   // File resizedImage = await getResizeImage(image);
    String imagesUrls='';
    String userid = Get.find<LoginController>().userModel.value!.uid!;
    String timestamp = timestamp1.millisecondsSinceEpoch.toString();
    Reference storageReference =  FirebaseStorage.instance.ref()
        .child('$COLLECTION_USERS/$userid/$COLLECTION_MATJIP/$docname/${timestamp}_$index.jpg');
    UploadTask uploadTask = storageReference.putFile(image, SettableMetadata(contentType: "image/jpeg",));
    logger.d('Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏãúÏûë, $index');
    await uploadTask.whenComplete(() async {
      imagesUrls = await storageReference.getDownloadURL();
    });
    logger.d('Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏôÑÎ£å!Ï≤¥ÌÅ¨,imagesUrls $index-> $imagesUrls');
    return imagesUrls;
  }

  Future<String> uploadThumbForWriteMatjip( {required File originImage, required String docname, required int index, required Timestamp timestamp1}) async{
    File resizedImage = await getResizeImage(originImage, thumb: true);
    String thumbUrls='';
    String userid = Get.find<LoginController>().userModel.value!.uid!;
    String timestamp = timestamp1.millisecondsSinceEpoch.toString();
    Reference thumbStorageReference =  FirebaseStorage.instance.ref()
        .child('$COLLECTION_USERS/$userid/$COLLECTION_MATJIP/$docname/thumb_${timestamp}_$index.jpg');
    UploadTask uploadTask = thumbStorageReference.putFile(resizedImage, SettableMetadata(contentType: "image/jpeg",));
    logger.d('Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏãúÏûë, $index');
    await uploadTask.whenComplete(() async {
      thumbUrls = await thumbStorageReference.getDownloadURL();
    });
    logger.d('Ïù¥ÎØ∏ÏßÄ thumb ÏóÖÎ°úÎìú ÏôÑÎ£å!Ï≤¥ÌÅ¨,imagesUrls $index-> $thumbUrls');
    return thumbUrls;
  }
  Future<List<dynamic>> getThumbImgUrls(List<dynamic> imageUrls) async{
    //Ïù¥Í±∞Î°ú ÌïòÎ©¥ ÎßõÏßë ÏàòÏ†ïÌï†Îïå ÏãúÍ∞Ñ ÎÑàÎ¨¥ ÎßéÏù¥ Í±∏Î¶º
    logger.d('imageurls->'+imageUrls.toString());
    List<String> thumbList = [];
    for(var url in imageUrls){
    try{
      Reference originRef =   FirebaseStorage.instance.refFromURL(url);
    var newRef = FirebaseStorage.instance.ref().child(originRef.parent!.fullPath+'/thumb_'+originRef.name);
    thumbList.add(await newRef.getDownloadURL());}catch(e){
      logger.e('thumb Ïò§Î•ò Î∞úÏÉù');
    }
    }
    logger.d('thumbList -> $thumbList');
    return thumbList;
  }
  //Deprecated 22.03.28
 /* Future<List<MatjipModel>> readSearchMatjipList(String myuid) async {
    logger.d("readSearchMatjipList() loaded!^^");
    List<MatjipModel> resultList = [];
    //ÎÇ¥Í∫ºÎûë ÏπúÍµ¨Îì§Í∫º ÏµúÏã† 100Í∞ú Í∞ÄÏ†∏Ïò§Í∏∞?
    await FirebaseFirestore.instance
        .collection(COLLECTION_MATJIP)
        .orderBy(KEY_CREATED, descending: true)
    //.where(KEY_MAKERUID, isNotEqualTo: myuid)
    //.orderBy(KEY_MAKERUID)
    //.where(KEY_MAKERUID, whereNotIn: [myuid])
        .limit(50)
        .get()
        .then((QuerySnapshot querySnapshot) {
      print('querySnapshot.size->${querySnapshot.size} ');
      querySnapshot.docs.forEach((doc) {
        if(doc.get(KEY_MAKERUID)!=myuid){
          resultList.add(MatjipModel.fromSnapshot(doc));
        }
      });
    });
    return resultList;
  }*/

  Future<List<MatjipModel>> queryManageMatjipList(String queryText, UserModel userModel, {int count=60,}) async{

    String selectedGrouping = Get.find<ManagerController>().selectedGrouping.value;
    String indice = '';
    logger.d('makeruid -> ${userModel.uid}\n selectedGrouping-> $selectedGrouping',);
      switch(selectedGrouping){
      case 'Î∞©Î¨∏Ïó¨Î∂Ä': indice= 'Matjip_Visited'; break;
      case 'ÏßÄÏó≠Î≥Ñ': indice= 'Matjip_Address'; break;
      case 'Ïπ¥ÌÖåÍ≥†Î¶¨': indice= 'Matjip_Category'; break;
      case 'ÏÉÅÌò∏Î≥Ñ': indice= 'Matjip_Name'; break;
      case 'ÎÇ†ÏßúÎ≥Ñ': indice= 'Matjip_Created'; break;
    }
    AlgoliaQuery query = algolia.instance.index(indice).query(queryText);
    // Perform multiple facetFilters
    query = query.facetFilter('makeruid:${userModel.uid}'); //-> write mine

    //TODO : Ïù¥Í≤å ÏùºÎã®ÏùÄ ÎÇ¥Í∞Ä groupingÏóê ÎåÄÌï¥ÏÑúÎäî Ïã†Í≤ΩÏì∞ÏßÄ ÏïäÏïòÎäîÎç∞, groupingÏùÑ Ìï¥ÏïºÌï† Í≤ΩÏö∞ÏóêÎäî orderbyÌï¥Ï£ºÎ©¥ Îê† ÎìØ
    //TODO : readManageMatjipList Ìï®Ïàò Ï∞∏Ï°∞Ìï† Í≤É!
    //query = query.facetFilter('isDelete:false');
    query = query.setHitsPerPage(count);
    AlgoliaQuerySnapshot snap = await query.getObjects();
    List<AlgoliaObjectSnapshot> hits =  snap.hits;
    List<MatjipModel> items =[];
    hits.forEach((element) {
      MatjipModel matjipmodel = MatjipModel.fromAlgolia(element.data,);
      logger.d('element object id -> ${element.objectID}, ${matjipmodel.created.toDate()}');
      items.add(matjipmodel);
    });
    logger.d(snap.toString());
    return items;
  }

  Future<List<MatjipModel>> readOthersMatjipList(  {int count = 10, required String uid}) async {
    List<MatjipModel> resultList = [];
    QuerySnapshot snapshot= await otherQuery.where(KEY_MAKERUID, isEqualTo: uid ).limit(count).get();
    for(QueryDocumentSnapshot doc in snapshot.docs)
      {
        var matjipmodel  = MatjipModel.fromSnapshot(doc);
        resultList.add(matjipmodel);
      }
  return resultList;
  }


  Future<List<MatjipModel>> readSquareMatjipList(  {int count = 10, String? tagString, DocumentReference? lastDocref, List<dynamic>? tagList}) async {
    logger.d("read Square MatjipList() loaded!^^ tagString: $tagString, tagList : $tagList");
    List<MatjipModel> resultList = [];
    Query query;
    if (tagString!=null&&tagString.isNotEmpty){
      query=squareQuery.where(KEY_TAGS, arrayContains: tagString );}else{query=squareQuery;}
    if(tagList!=null)
    {if(tagList.isNotEmpty){
      query = query.where(KEY_TAGS, arrayContainsAny: tagList);
    } }

      if (lastDocref!=null){query = query.startAfterDocument(await lastDocref.get());}
        await query.limit(count).get().then((QuerySnapshot querySnapshot) {
          logger.d('query ${querySnapshot.size} Í∞ú Ï∞æÏùå');
          Get.find<SquareController>().setScrollable(querySnapshot.size>=count);
          for(QueryDocumentSnapshot doc in querySnapshot.docs)
          {
            var matjipmodel  = MatjipModel.fromSnapshot(doc);
            if((Get.find<LoginController>().userModel.value?.blockingUsers?.contains(matjipmodel.makeruid)??false)||
                (Get.find<LoginController>().userModel.value?.blockedUsers?.contains(matjipmodel.makeruid)??false)){
              logger.d('Ï∞®Îã®Îê® ${doc[KEY_MATJIPNAME]}');
              continue;}
            resultList.add(matjipmodel);
          }
    });
    return resultList;
  }
  Future<List<MatjipModel>> readManageMatjipList(String myuid, {int count = 15, String? selectedGrouping= 'ÎÇ†ÏßúÎ≥Ñ', DocumentReference? lastDocref}) async {

    logger.d("readManageMatjipList() loaded!^^  selectedGrouping $selectedGrouping");
    List<MatjipModel> resultList = [];
    //ÎÇ¥Í∫ºÎûë ÏπúÍµ¨Îì§Í∫º ÏµúÏã† 100Í∞ú Í∞ÄÏ†∏Ïò§Í∏∞?
    var query =  FirebaseFirestore.instance.collection(COLLECTION_MATJIP).where(KEY_MAKERUID, isEqualTo: myuid);
    switch(selectedGrouping){
      case 'Î∞©Î¨∏Ïó¨Î∂Ä': query= query.orderBy(KEY_VISITED, descending: true).orderBy(KEY_CREATED, descending: true); break;
      case 'ÏßÄÏó≠Î≥Ñ': query= query.orderBy(KEY_ADDRESS_SIMPLE, ).orderBy(KEY_CREATED, descending: true); break;
      case 'Ïπ¥ÌÖåÍ≥†Î¶¨': query= query.orderBy(KEY_ORDER_CATEGORY, ).orderBy(KEY_CREATED, descending: true); break;
      case 'ÏÉÅÌò∏Î≥Ñ': query= query.orderBy(KEY_MATJIPNAME, ); break;
      case 'ÎÇ†ÏßúÎ≥Ñ': query= query.orderBy(KEY_CREATED, descending: true);break;
    }
    if (lastDocref!=null){query = query.startAfterDocument(await lastDocref.get());}
    await query.limit(count).get().then((QuerySnapshot querySnapshot) {
      querySnapshot.docs.forEach((doc) {

        resultList.add(MatjipModel.fromSnapshot(doc));
      });
    });
    return resultList;
  }
  Future<List<MatjipModel>> fetchMatjipList(DocumentReference documentReference, {UserModel? filterUser}) async {
    logger.d("fetch MatjipList() loaded!^^ filterUser-> ${filterUser?.nickname}");
    List<MatjipModel> resultList = [];
    //ÎÇ¥Í∫ºÎûë ÏπúÍµ¨Îì§Í∫º ÏµúÏã† 100Í∞ú Í∞ÄÏ†∏Ïò§Í∏∞?
    Query query;
    if(filterUser== null){
      //square
      query = squareQuery;
    }else{
      //manager
      query = FirebaseFirestore.instance
          .collection(COLLECTION_MATJIP).where(KEY_MAKERUID, isEqualTo: filterUser.uid)
          .orderBy(KEY_CREATED, descending: true);
    }
    await query
        .endBeforeDocument(await documentReference.get())
        .limit(50)
        .get()
        .then((QuerySnapshot querySnapshot) {
      querySnapshot.docs.forEach((doc) {
        logger.d("fetch MatjipList doc ->"+doc[KEY_MATJIPNAME]);
        resultList.add(MatjipModel.fromSnapshot(doc));
      });
    }).onError((error, stackTrace) async{
      await Future.delayed(Duration(milliseconds: 200));
      fetchMatjipList(documentReference);
    });
    return resultList;
  }

  Future<List<MatjipModel>> readFollowMatjipList(  {int count = 4, String? tagString, DocumentReference? lastDocref}) async {
    logger.d('follow matjip LIst');
    UserModel? myUserModel = Get.find<LoginController>().userModel.value;
    if(myUserModel==null){return [];}
    logger.d("read Square MatjipList() loaded!^^ tagString: $tagString");
    List<MatjipModel> resultList = [];
    Query query;
    query=squareQuery;
    query = query.where(KEY_MAKERUID, whereIn: myUserModel.following);
    if (lastDocref!=null){query = query.startAfterDocument(await lastDocref.get());}
    await query.limit(count).get().then((QuerySnapshot querySnapshot) {
      for(QueryDocumentSnapshot doc in querySnapshot.docs)
      {
        var matjipmodel  = MatjipModel.fromSnapshot(doc);
        if((Get.find<LoginController>().userModel.value?.blockingUsers?.contains(matjipmodel.makeruid)??false)||
            (Get.find<LoginController>().userModel.value?.blockedUsers?.contains(matjipmodel.makeruid)??false)){
          logger.d('Ï∞®Îã®Îê® ${doc[KEY_MATJIPNAME]}');
          continue;}
        resultList.add(matjipmodel);
      }
    });
    return resultList;
  }

  Future<List<MatjipModel>> existMyMatjips(UserModel userModel, String placeId) async{
    List<MatjipModel> resultList =[];
    var query  = await FirebaseFirestore.instance.collection(COLLECTION_MATJIP).where(KEY_MAKERUID, isEqualTo: userModel.uid)
        .where(KEY_PLACE_ID, isEqualTo: placeId).get();
    logger.d('ÏùΩÏñ¥ Îì§Ïù∏ doc Ïàò -> ${query.docs.length} , $placeId' );
    query.docs.forEach((doc) async{
      logger.d("fetch MatjipList doc -> ${doc.id}");
      resultList.add(MatjipModel.fromSnapshot(doc));
    });
    return resultList;
  }

  Future<int> queryWithTag(String queryText, {int count = 40}) async{
    var query  = await FirebaseFirestore.instance.collection(COLLECTION_MATJIP).where(KEY_TAGS, arrayContains: queryText)
    .limit(count).get();
    logger.d('ÏùΩÏñ¥ Îì§Ïù∏ doc Ïàò -> ${query.docs.length}' );
    return query.docs.length;
  }

  Future<List<MatjipModel>> getAlgoliaWithTag(String queryText) async{
    AlgoliaQuery query = algolia.instance.index('MATJIP').query(queryText);
    query = query.setHitsPerPage(3);
    AlgoliaQuerySnapshot snap = await query.getObjects();
    List<AlgoliaObjectSnapshot> hits =  snap.hits;
    List<MatjipModel> items =[];
    hits.forEach((element) {
      MatjipModel matjipmodel = MatjipModel.fromAlgolia(element.data,);
      print('element object id -> ${element.objectID}, ${matjipmodel.created.toDate()}');
      items.add(matjipmodel);
    });
    return items;
  }

  Future<List<MatjipModel>> getMyMatjipList(String userUid,  {int count = 10}) async{
    List<MatjipModel> resultList = [];
    var query  = await FirebaseFirestore.instance.collection(COLLECTION_MATJIP).where(KEY_MAKERUID, isEqualTo: userUid)
        .limit(count).get();
    logger.d('ÏùΩÏñ¥ Îì§Ïù∏ doc Ïàò -> ${query.docs.length}' );
    query.docs.forEach((doc) async{ resultList.add(MatjipModel.fromSnapshot(doc));});
    return resultList;
  }
/*  Future<List<MatjipModel>> getMatjipLikeList(String matjipid,  {int count = 20}) async{
    List<MatjipModel> resultList = [];
    var query  = await FirebaseFirestore.instance.collection(COLLECTION_USERS).where(KEY_UID, isEqualTo: userUid)
        .limit(count).get();
    logger.d('ÏùΩÏñ¥ Îì§Ïù∏ doc Ïàò -> ${query.docs.length}' );
    query.docs.forEach((doc) async{ resultList.add(MatjipModel.fromSnapshot(doc));});
    return resultList;
  }*/



 /*Future allmatjipSetting() async{
  var query  = await FirebaseFirestore.instance.collection(COLLECTION_MATJIP).orderBy(KEY_MATJIPNAME).get();
  logger.d('ÏùΩÏñ¥ Îì§Ïù∏ doc Ïàò -> ${query.docs.length}' );
  query.docs.forEach((doc) async{
    logger.d("fetch MatjipList doc -> ${doc[KEY_MATJIPID]}");
    var matjipmodel =  MatjipModel.fromSnapshot(doc);
    var created  = matjipmodel.created;
    var categoryName  = matjipmodel.categoryName;
    matjipmodel.orderDate = DateFormat('yy.MM.',).format(created.toDate());
   try{
     if (categoryName!=null){
       matjipmodel.orderCategory = categoryName.split('>')[1].trim();
     }else{
       matjipmodel.orderCategory = 'ü•ò Í∏∞ÌÉÄ';
     }
   }catch(e){
     matjipmodel.orderCategory = 'ü•ò Í∏∞ÌÉÄ';
   }
    await FirebaseFirestore.instance.collection(COLLECTION_MATJIP).doc(matjipmodel.matjipid).set(matjipmodel.toJson(),SetOptions(merge: true) );
  });
  return;
 }
  Future allmatjipDatafromKaKaoForAdmin() async{
    var query  = await FirebaseFirestore.instance.collection(COLLECTION_MATJIP).orderBy(KEY_MATJIPNAME).get();
    logger.d('ÏùΩÏñ¥ Îì§Ïù∏ doc Ïàò -> ${query.docs.length}' );
    for(int i=0; i<query.docs.length;i++)
    {
      logger.d("1fetch MatjipList doc -> ${query.docs[i][KEY_MATJIPID]}");
      var matjipmodel =  MatjipModel.fromSnapshot(query.docs[i]);


      Map<String, dynamic> map = matjipmodel.toJson();

      KakaoPlaceModel? kakaoPlaceModel = await searchNetworkRepository.findKakaoPlaceWithQuery(matjipmodel.matjipname??'', matjipmodel.geolocation??GeoPoint(37.565760, 126.977927));
      if(kakaoPlaceModel==null){logger.d('kakaoPlaceModel == null'); continue;}
      if(kakaoPlaceModel.documents!.isNotEmpty){
        kakaoPlaceModel.documents!.sort((a, b) => a.distance!.compareTo(b.distance!));
      }
      KaKaoPlaceDocument? selectedMatjip;

       await Get.dialog(  AlertDialog(
         title: Text('${matjipmodel.matjipname}, ${matjipmodel.address}'),
         content: SingleChildScrollView(
           child: Column(
             children: List.generate(
                 kakaoPlaceModel.documents?.length ?? 0, (index) =>
                 InkWell(
                   onTap: (){
                   },
                   child: Container(
                     color: index==0? Colors.grey: Colors.white,
                     child: Row(
                       mainAxisAlignment: MainAxisAlignment.spaceBetween,
                       children: [
                         Text('${kakaoPlaceModel.documents![index].placeName}?'),
                         Text('${kakaoPlaceModel.documents![index].distance}m')
                       ],
                     ),
                   ),
                 )),
           ),
         ),
         actions: [
           TextButton(onPressed: () {
             Get.back();
             selectedMatjip = kakaoPlaceModel.documents![0];
           }, child: Text('ÌôïÏù∏')),
           TextButton(onPressed: () {
             Get.back();
           }, child: Text('Ï∑®ÏÜå')),
         ],
       )
     );


      if(selectedMatjip!=null)
     {
       logger.d('selectmatjip is not null');
       var addresssimpleList  = selectedMatjip!.roadAddressName!.split(" ");
     map[KEY_MATJIPNAME]= selectedMatjip!.placeName;
     map[KEY_ADDRESS]= selectedMatjip!.roadAddressName;
     map[KEY_CATEGORY_GROUP_NAME]=  selectedMatjip!.categoryGroupName;
     map[KEY_CATEGORY_NAME]=  selectedMatjip!.categoryName;
     map[KEY_KAKAO_ID]=  selectedMatjip!.id;
     map[KEY_PHONE]=  selectedMatjip!.phone;
     map[KEY_KAKAO_URL]=  selectedMatjip!.placeUrl;
     map[KEY_PLACE_ID] = '${selectedMatjip!.placeName}_${selectedMatjip!.lat!}_${selectedMatjip!.lng!}';
     map[KEY_GEO_LOCATION] = GeoPoint(selectedMatjip!.lat!.toDouble(), selectedMatjip!.lng!.toDouble());}else{
        logger.d('selectmatjip is null');
      }

      await FirebaseFirestore.instance.collection(COLLECTION_MATJIP).doc(matjipmodel.matjipid).set(map,SetOptions(merge: true) );

    }
 *//*   query.docs.forEach((doc) async{
         });*//*
    return;
  }
*/







  //Ïπ¥Ïπ¥Ïò§Î°ú ÎåÄÏ≤¥ Îê® 22.02.13 -> Ïô∏Íµ≠ ÏÑúÎ≤ÑÏóê ÌïÑÏöîÌï® ÏßÄÏö∞ÏßÄ Îßê Í≤É
/*  Future<List<GoogleLocation>> searchNearbyMatjipListFromGoogle() async{
    var position = await getPosition();
    logger.d("matjip near search list");
    logger.d("{position.longitude} : ${position.longitude} + {position.latitude} :${position.latitude} ");

    var matjipQueryRequest = await Dio().request(
        "https://maps.googleapis.com/maps/api/place/nearbysearch/json",
        queryParameters: {
          "type": "restaurant",
          "key": myGoogleApiKey,
          "location": "${position.latitude} , ${position.longitude}",
          "language": "ko",
          //"keyword": "ÎßõÏßë",
         // "radius": "1000",
          "rankby": "distance",
         // "type": "food",
        });
    logger.d("matjip near search list ÎèåÏïÑÍ∞ÄÏïºÌï†Íπå? ${matjipQueryRequest.data["results"].toString()}");
    List<GoogleLocation> resultArray=[];
    resultArray.addAll(List.generate(matjipQueryRequest.data["results"].length, (index) =>
        GoogleLocation.fromNearbyJson(matjipQueryRequest.data["results"][index])));
    return resultArray;
  }*/

  //Ïπ¥Ïπ¥Ïò§Î°ú ÎåÄÏ≤¥ Îê® 22.02.13 -> Ïô∏Íµ≠ ÏÑúÎ≤ÑÏóê ÌïÑÏöîÌï® ÏßÄÏö∞ÏßÄ Îßê Í≤É
/*  Future<List<GoogleLocation>> searchMatjipListWithQueryFromGoogle(String query) async{
    var position = await getPosition();
    print("matjip near search list with query");
    print("{position.longitude} : ${position.longitude} + {position.latitude} :${position.latitude} ");
   *//* var matjipQueryRequest = await Dio().request(
        "https://maps.googleapis.com/maps/api/place/nearbysearch/json",
        queryParameters: {
          "key": myGoogleApiKey,
          "location": "${position.latitude} , ${position.longitude}",
          "radius": "800000",
          //"type": "food",
          "type": "restaurant",
          "language": "ko",
          "keyword": query,
         // "rankby": "distance",
        });*//*

    var matjipQueryRequest = await Dio().request(
        "https://maps.googleapis.com/maps/api/place/textsearch/json",
        queryParameters: {
          "type": "food",
          "query": query,
          "key": myGoogleApiKey,
          "location": "${position.latitude} , ${position.longitude}",
          //"radius": "800000",
          //"type": "food",
          "language": "ko",
          // "rankby": "distance",
        });
    logger.d("matjip near search list with query ÎèåÏïÑÍ∞ÄÏïºÌï†Íπå? ${matjipQueryRequest.data["results"].toString()}");
    List<GoogleLocation> resultArray=[];
    resultArray.addAll(List.generate(matjipQueryRequest.data["results"].length, (index) =>
        GoogleLocation.fromJson(matjipQueryRequest.data["results"][index])));
    return resultArray;
  }*/

  //Ïπ¥Ïπ¥Ïò§Î°ú ÎåÄÏ≤¥ Îê® 22.02.13 -> Ïô∏Íµ≠ ÏÑúÎ≤ÑÏóê ÌïÑÏöîÌï® ÏßÄÏö∞ÏßÄ Îßê Í≤É
/*  Future<List<String>> autoCompleteListFromGoogle(String query) async{
    var position = await getPosition();
    print("matjip autoCompleteList");
    logger.d("{position.longitude} : ${position.longitude} + {position.latitude} :${position.latitude} ");
    var matjipQueryRequest = await Dio().request(
        "https://maps.googleapis.com/maps/api/place/queryautocomplete/json",
        queryParameters: {
          "input": query,
          "key": myGoogleApiKey,
          "location": "${position.latitude} , ${position.longitude}",
          "radius": "30000",
          "type": "food",
          "language": "ko",
     //     "rankby": "distance",
        });
    logger.d("autoCompleteList? ${matjipQueryRequest.data["predictions"].toString()}");
    List<String> resultArray=[];

    for(int i=0;i<matjipQueryRequest.data["predictions"].length; i++){
      var newstring =matjipQueryRequest.data["predictions"][i]["structured_formatting"]["main_text"];
      if(resultArray.indexOf(newstring)==-1){
        resultArray.add(newstring);
      }
    }


    return resultArray;
  }*/










}

MatjipNetworkRepository matjipNetworkRepository = MatjipNetworkRepository();


/*
22.02.17 ÏÇ≠Ï†ú
Future<FirebaseFolderModel> addPersonalFolder( {required String folderName, required UserModel userModel}) async{
  late FirebaseFolderModel folderModel;
  DocumentReference folderRef = FirebaseFirestore.instance.collection(COLLECTION_FOLDERS).doc();
  DocumentReference userRef = FirebaseFirestore.instance.collection(COLLECTION_USERS)
      .doc(userModel.uid);
  final DocumentSnapshot folderSnapshot = await folderRef.get();
  final DocumentSnapshot userSnapshot = await userRef.get();
  if(!folderSnapshot.exists&& !userSnapshot.exists){
    await FirebaseFirestore.instance.runTransaction((transaction) async{
      var newfolderModel = {
        "created": Timestamp.now(),
        "update": Timestamp.now(),
        "folderid": folderRef.id,
        "foldername": folderName,
        "makerimg": userModel.userimg,
        "makeruid": userModel.uid,
        "makername": userModel.nickname,
      };

      transaction.set(folderRef, newfolderModel);
      transaction.update(userRef, {KEY_FOLDERS: FieldValue.arrayUnion([newfolderModel])});
      // await Get.find<MatjipController>().addFolder(FirebaseFolderModel.fromMap(newfolderModel));
      folderModel= FirebaseFolderModel.fromMap(newfolderModel);
    });

  }else{showToast('Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');}
  print('ÏûëÏÑ± ÏôÑÎ£å');
  return folderModel;
}*/
